## 스택(Stack)
 + LIFO(Last In First Out): 후입선출의 형식으로 입출력이 일어나는 자료구조

![image](https://user-images.githubusercontent.com/38236367/144990537-3086c0f7-d6fd-43bc-bc49-fe8454803cd2.png)
 + 스택은 위, 아래 중 한 곳에서만 삽입, 삭제가 일어날 수 있는 자료구조이다.
 + 스택의 Push연산은 삽입연산으로 스택의 맨 위에(Top) 원소를 넣는다.
 + 스택의 Top연산은 맨 위에 있는 원소를 참조하여 반환한다. 위 그림에서 맨 위에 있는 자료는 2이므로 2를 반환하게된다.
 + 스택이 비어있을 경우 Top은 -1의 값을 반환한다. 배열에서 첫 번째 원소의 인덱스는 0이기 때문에 Top의 값이 0이면 배열의 인덱스 0에 데이터가 있다는 것을 의미하기 때문에 스택이 비어있을 경우 Top은 -1의 값을 가지게 된다.
 + 스택의 Size연산은 원소의 개수를 반환한다. 위 그림에서 스택의 내부 원소는 1, 2이므로 2를 반환한다.

![image](https://user-images.githubusercontent.com/38236367/144991395-986b5cd1-d546-490d-84bc-cb16bc4d70a0.png)
 + 스택의 empty연산은 스택이 비어있는지 아닌지를 알기위한 연산이다. 스택이 비어있을 경우 True값을 반환하고 비어있지 않을 경우 False값을 반환한다. 위 그림에서는 False값이 반환된다.
 + 스택의 Pop연산은 맨 위에 있는 자료를 삭제하고 그 값을 반환한다. 위 그림에서 2를 먼저 pop수행하고, 1을 pop수행했으므로 2, 1의 순서대로 출력이된다.
 + 마지막 그림의 empty연산에서 스택이 비어있으므로 True값을 반환한다. 

---

## 연결리스트를 이용한 스택
 + 배열로 구현한 스택은 크기가 고정되어있는 반면 연결리스트로 구현한 스택은 크기의 제한이 없다. 동적메모리만 할당할 수 있다면 새로운 원소를 삽입할 수 있다.
 + 연결리스트를 이용한 스택은 동적메모리 할당이나 해제를 해야하므로 삽입이나 삭제의 시간이 더 걸린다.


### 데이터 삽입
![image](https://user-images.githubusercontent.com/38236367/144992151-387497d2-e480-4e20-bff8-81be31b88d8a.png)
 + Top은 첫 번째 노드를 가리킨다.

![image](https://user-images.githubusercontent.com/38236367/144992322-3922ab3c-5ac2-44d6-b04a-93543c11ff2b.png)
 + 데이터 30을 저장할 노드를 생성하고, 데이터 영역에 저장한다.

![image](https://user-images.githubusercontent.com/38236367/144993527-a017e30c-2bf1-4e58-b362-ef027ae85f9a.png)
 + 새롭게 생성된 데이터 30인 노드의 포인터 영역이 Top이 가리키는 곳을 가리키게 한다.

![image](https://user-images.githubusercontent.com/38236367/144994187-3da94591-98b9-47a9-af65-bb8c2c0e1435.png)
 + Top이 새롭게 생성된 데이터 30인 노드를 가리키게 한다.

### 데이터 삭제
![image](https://user-images.githubusercontent.com/38236367/144994251-834aad4f-81fc-461b-9d84-843d680aa577.png)
 + Top이 가리키는 노드의 포인터 영역이 가리키는 곳을 Top이 가리키게 한다. 따라서 Top은 데이터 10인 노드를 가리키게 된다.

![image](https://user-images.githubusercontent.com/38236367/144994347-315bf871-1c94-49b9-a5c6-a65d6243af29.png)
 + 데이터가 20인 노드를 삭제하면 삭제동작이 완료된다.

---

## 배열을 활용한 원형 큐(Queue)
 + 큐는 스택과 달리 한쪽 방향으로 데이터가 삽입되고 반대 방향으로 데이터가 삭제되는 구조이다.
 + 큐는 가장 먼저 삽입된 데이터가 가장 먼저 삭제되므로 선입선출(FIFO)의 특징을 갖는다.

### 원형 큐
 + 원형 큐는 원형으로 생긴 배열 리스트를 이용하여 구현한 큐이다. 시작점과 마지막점을 구분하기 위해서 Front와 Rear라는 개념을 사용한다.
 + 원형 큐는 상황에따라 언더플로 또는 오버플로가 발생하는데, 언더플로는 원형 큐에 데이터가 없어서 더 이상 빼낼 수 없는 경우를 의미하고 반대로 오버플로는 데이터가 가득 차 더 이상 데이터를 추가할 수 없는 경우를 의미한다.
 + 데이터를 추가할 때 오버플로가 발생하지 않는다면 Rear위치에 데이터를 추가하고, 데이터 제거 시 언더플로가 발생하지 않는다면 Front에 데이터를 제거하여 원형큐를 구현한다.
