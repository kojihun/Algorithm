## 해시(Hash)
 + 해시 테이블: 키 값의 연산에 의해 직접 접근이 가능한 구조의 테이블
 + 해싱: 해시 테이블을 이용한 탐색

## 해싱(Hashing)
 + 해싱에서는 자료를 저장하는데 배열을 사용한다. 배열은 크기를 한 번 지정하면 늘리거나 줄일 수 없지만, 원하는 항목이 저장된 위치를 알고 있다면 매우 빠르게 자료를 삽입하거나 꺼낼 수 있다. 이 경우 배열의 다른 요소들에게 전혀 접근할 필요가 없다.
 + 해시함수라는 탐색 키(Key)를 입력받는다 -> 해시 주소 생성(해시 테이블의 인덱스)
 + 해싱에서 키 값을 해시 테이블의 주소로 변환하는 해시 함수가 잘 설계되어야만 탐색의 효울을 증가시킬 수 있다. 좋은 해시 함수의 조건은 다음 3가지이다.
   + 해시 함수 값이 해시 테이블의 주소 영역 내에서 고르게 분포되어야 한다.
   + 충돌이 적어야 한다.
   + 계산이 빨라야 한다.

## 해시 함수의 종류
 + 제산함수: 나머지 연산자를 사용하여 탐색 키를 해시 테이블의 크기로 나눈 나머지를 해시 주소로 사용하는 방법, 이상적인 테이블의 크기는 소수로 나누어지지 않는 수로 정해야한다.
 + 폴딩함수: 탐색 키를 여러 부분으로 나누어 모두 더한 값을 해시 주소로 사용한다. 폴딩함수의 종류는 2가지가 있다.
   + 이동폴딩: 탐색 키를 여러 부분으로 나눈 값들을 더하여 해시 주소로 사용
   + 경계폴딩: 탐색 키의 이웃한 부분은 거꾸로 더하여 해시 주소로 사용

## 충돌 해결법
 + 충돌: 서로 다른 탐색 키를 갖는 항목들이 같은 해시 주소를 가지는 현상, 충돌이 발생하면 해시 테이블에 항목을 더 이상 저장하는 것이 불가능함
 + 충돌 해결법에는 4가지 종류가 있다.
   + 선형 조사법(linear probing): 특정 버켓에서 충돌이 발생하면 해시 테이블에서 비어있는 버켓을 찾는 방법, 충돌이 발생할 경우 다음 빈 공간을 찾을 때 까지 계속 조사하는 방법이다. 만약 테이블의 끝에 도달했을 경우 처음으로 돌아간다.
   + 이차 조사법(quadratic probing): 선형 조사법과 비슷하지만 선형 조사법은 버켓에서 충돌이 일어나면 다음 버켓을 찾아가는데 반하여 이차 조사법은 제곱하여 주소 값을 얻어 해당 위치의 버켓에 저장한다.
   + 이중 해싱법: 오버플로(Overflow)가 발생함에 따라 항목을 저장할 다음 위치를 결정할 때, 원래 해시 함수와 다른 별개의 해시 함수를 이용하는 방법
   + 체이닝: 오버플로(Overflow)가 발생할 경우 연결 리스트로 문제를 해결하는 방법

---

## 그래프(Graph)
 + 그래프는 연결되어 있는 객체 간의 관계를 표현할 수 있는 자료 구조
 + 그래프는 정점과 간선들의 집합으로 구성되어 있다.

## 그래프의 종류
 + 무방향 그래프: 간선을 통해 양방향으로 갈 수 있는 그래프
 + 방향 그래프: 간선에 방향성이 존재해 한쪽 방향으로만 갈 수 있는 그래프
 + 가중치 그래프: 간선에 가중치를 할당하여 효율적인 경로를 파악할 수 있는 그래프
 + 연결 그래프: 모든 정점 쌍에 대하여 항상 경로가 존재하는 그래프
 + 완전 그래프: 그래프에 속해 있는 모든 정점이 서로 연결되어 있는 그래프

## 그래프의 표현 방법
 + 1, 2차원 배열을 사용하는 인접행렬
 + 연결 리스트를 사용하는 인접리스트

## 그래프 탐색
 + 깊이우선탐색: 그래프의 시작 정점에서 출발하여 시작 정점을 방문하고 체크한다 -> 시작 정점과 인접한 정점들 중 방문하지 않은 정점을 선택한다 -> 더 이상 방문할 정점이 없다면 탐색을 종료하고, 방문하지 않은 정점이 있을 경우 다시 시작 정점으로 돌아가 깊이우선탐색을 시작한다
 + 너비우선탐색: 시작 정점으로부터 가까운 정점을 먼저 방문하고 멀리 떨어져있는 정점을 나중에 방문하는 탐색방법, 너비우선탐색을 수행하기 위해서는 방문한 정점들을 차례로 저장한 후 꺼낼수 있는 자료구조인 큐가 필요하다. 정점이 방문될때마다 큐에 방문된 정점을 삽입한다 -> 더 이상 방문할 인접 정점이 없는 경우 큐의 앞에서 정점을 꺼내어 그 정점과 인접한 정점들을 모두 차례대로 방문한다 -> 큐가 비어있지 않다면 탐색을 계속 수행한다.

## 트리(Tree)
 + 신장트리: 그래프 내 모든 정점을 포함하는 트리, 신장트리는 모든 정점들이 연결되어야 하고 사이클을 포함해서는 안된다.
 + 최소비용 신장트리: 가장 적은 수의 간선과 비용으로 연결하는 신장트리
 + 크루스칼 알고리즘: 각 선택마다 탐욕적인 방법을 이용해서 모든 정점을 최소한의 비용으로 연결
   + 그래프들의 간선을 오름차순으로 정렬한다 -> 오름차순으로 정렬된 간선들을 하나씩 빼서 연결한다(사이클 존재X) -> 두 번째 동작을 반복하며 최소비용 신장트리를 만들어간다.
 + 프림 알고리즘: 주어진 그래프에서 BFS와 우선순위 큐를 이용하여 최소비용 신장트리를 구하는 알고리즘

## 경로
 + 최단경로: 네트워크에서 정점 U와 정점 V를 연결하는 경로 중 간선들의 가중치 합이 최소가 되는 경로를 찾는 문제
 + 다익스트라 알고리즘: 네트워크에서 하나의 시작 정점으로부터 모든 다른 정점까지 최단경로를 찾는 알고리즘(그래프 가중치에 음수 허용X)
 + 벨만포드 알고리즘: 한 정점에서 모든 정점으로 가는 최단 경로를 찾는 알고리즘, 한 번 수행 시 모든 간선을 탐색해야한다.
